{# demos/templates/demos/ml_visualization_static_demo.html #}
{% extends 'portfolio/base.html' %} {# Assumes base.html is in portfolio app #}
{% load static %}
{% load humanize %} {# Optional: if you need number formatting filters #}

{% block title %}Static ML Visualization Demo - Portfolio{% endblock %}
{% block meta_description %}Demonstration of creating static Machine Learning charts using Python (Matplotlib/Seaborn) in a Django application.{% endblock %}
{% block meta_keywords %}django, python, matplotlib, seaborn, static charts, data visualization, machine learning charts, confusion matrix, roc curve, feature importance, learning curve{% endblock %}

{% block content %}
<div class="container mx-auto px-4 sm:px-6 py-12 font-inter">

    {# 1. Heading and Introduction #}
    <header class="text-center mb-12">
        <h1 class="text-4xl md:text-5xl font-bold mb-6 bg-gradient-to-r from-teal-500 via-blue-500 to-indigo-500 dark:from-teal-400 dark:via-blue-400 dark:to-indigo-400 bg-clip-text text-transparent">
            Static ML Visualization (Django + Matplotlib)
        </h1>
        <p class="text-gray-600 dark:text-gray-400 max-w-3xl mx-auto">
            This demo showcases how Python, using libraries like Matplotlib and Seaborn within a Django view, can generate static chart images displayed directly in the HTML. No client-side JavaScript is needed for rendering the charts.
        </p>
        {% if error_message %}
            <div class="mt-6 max-w-xl mx-auto p-4 rounded-lg bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200" role="alert">
                <strong class="font-semibold">Error:</strong> {{ error_message }}
            </div>
        {% endif %}
    </header>

    {# 2. Main Content Area - Sections for each plot type #}
    <div class="max-w-4xl mx-auto space-y-12">

        {# Section: Confusion Matrix #}
        <section id="confusion-matrix" class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg dark:shadow-indigo-900/20 transition-colors duration-300 ease-in-out">
            <h2 class="text-2xl font-semibold text-gray-800 dark:text-gray-100 mb-4 border-b border-gray-200 dark:border-gray-700 pb-3">
                1. Confusion Matrix
            </h2>
            <div class="prose prose-indigo dark:prose-invert max-w-none text-gray-700 dark:text-gray-300 leading-relaxed text-sm mb-5">
                <p>A Confusion Matrix evaluates classification performance by showing True Positives, True Negatives, False Positives, and False Negatives.</p>
                <p><strong>Backend Role:</strong> Calculate the matrix values and generate the heatmap image using Seaborn/Matplotlib.</p>
            </div>

            <h3 class="text-lg font-medium text-gray-700 dark:text-gray-200 mb-2">Python Plotting Code (Django View):</h3>
            <pre class="text-xs block overflow-x-auto p-4 bg-gray-900 text-gray-100 rounded-md shadow mb-4"><code class="language-python">
# --- Inside Django View ---
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix
# ... get y_test, y_pred, cm_labels ...
cm = confusion_matrix(y_test, y_pred)

fig_cm, ax_cm = plt.subplots(figsize=(5, 4)) # Create figure and axes
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', ax=ax_cm,
            xticklabels=cm_labels, yticklabels=cm_labels,
            annot_kws={"size": 12})
ax_cm.set_title('Confusion Matrix', fontsize=14)
ax_cm.set_ylabel('Actual Labels', fontsize=12)
ax_cm.set_xlabel('Predicted Labels', fontsize=12)
plt.xticks(rotation=0)
plt.yticks(rotation=0)
plt.tight_layout() # Ensure layout fits well before saving

# Save to buffer and encode (using helper function _plot_to_base64)
# context['confusion_matrix_b64'] = _plot_to_base64(fig_cm)
# --- End View Snippet ---
            </code></pre>

            <h3 class="text-lg font-medium text-gray-700 dark:text-gray-200 mb-2">Generated Plot:</h3>
            <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded border border-gray-200 dark:border-gray-600 shadow-inner flex justify-center items-center">
                {% if confusion_matrix_b64 %}
                    <img src="data:image/png;base64,{{ confusion_matrix_b64 }}" alt="Confusion Matrix" class="max-w-full h-auto rounded">
                {% else %}
                    <p class="text-red-500 italic">[Confusion Matrix image could not be generated]</p>
                {% endif %}
            </div>
            <p class="text-xs text-center text-gray-500 dark:text-gray-400 mt-1">Static image generated by Matplotlib/Seaborn.</p>
        </section>

        {# Section: ROC Curve #}
        <section id="roc-curve" class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg dark:shadow-indigo-900/20 transition-colors duration-300 ease-in-out">
            <h2 class="text-2xl font-semibold text-gray-800 dark:text-gray-100 mb-4 border-b border-gray-200 dark:border-gray-700 pb-3">
                2. ROC Curve & AUC
            </h2>
            <div class="prose prose-indigo dark:prose-invert max-w-none text-gray-700 dark:text-gray-300 leading-relaxed text-sm mb-5">
                <p>The ROC curve plots True Positive Rate vs. False Positive Rate, showing classifier performance across thresholds. AUC summarizes this.</p>
                 <p><strong>Backend Role:</strong> Calculate FPR, TPR, AUC, and generate the plot image using Matplotlib.</p>
            </div>

            <h3 class="text-lg font-medium text-gray-700 dark:text-gray-200 mb-2">Python Plotting Code (Django View):</h3>
            <pre class="text-xs block overflow-x-auto p-4 bg-gray-900 text-gray-100 rounded-md shadow mb-4"><code class="language-python">
# --- Inside Django View ---
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc
# ... get y_test, y_scores ...
fpr, tpr, thresholds = roc_curve(y_test, y_scores)
roc_auc_score = auc(fpr, tpr)

fig_roc, ax_roc = plt.subplots(figsize=(6, 5))
ax_roc.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (AUC = {roc_auc_score:.2f})')
ax_roc.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--', label='Chance (AUC = 0.50)')
ax_roc.set_xlim([0.0, 1.0])
ax_roc.set_ylim([0.0, 1.05])
ax_roc.set_xlabel('False Positive Rate (FPR)', fontsize=12)
ax_roc.set_ylabel('True Positive Rate (TPR)', fontsize=12)
ax_roc.set_title('Receiver Operating Characteristic (ROC) Curve', fontsize=14)
ax_roc.legend(loc="lower right", fontsize=10)
ax_roc.grid(alpha=0.3)
plt.tight_layout()

# Save to buffer and encode
# context['roc_curve_b64'] = _plot_to_base64(fig_roc)
# --- End View Snippet ---
            </code></pre>

             <h3 class="text-lg font-medium text-gray-700 dark:text-gray-200 mb-2">Generated Plot:</h3>
             <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded border border-gray-200 dark:border-gray-600 shadow-inner flex justify-center items-center">
                 {% if roc_curve_b64 %}
                    <img src="data:image/png;base64,{{ roc_curve_b64 }}" alt="ROC Curve" class="max-w-full h-auto rounded">
                 {% else %}
                    <p class="text-red-500 italic">[ROC Curve image could not be generated]</p>
                 {% endif %}
             </div>
             <p class="text-xs text-center text-gray-500 dark:text-gray-400 mt-1">Static image generated by Matplotlib.</p>
        </section>

        {# Section: Feature Importance #}
        <section id="feature-importance" class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg dark:shadow-indigo-900/20 transition-colors duration-300 ease-in-out">
            <h2 class="text-2xl font-semibold text-gray-800 dark:text-gray-100 mb-4 border-b border-gray-200 dark:border-gray-700 pb-3">
                3. Feature Importance Plot
            </h2>
            <div class="prose prose-indigo dark:prose-invert max-w-none text-gray-700 dark:text-gray-300 leading-relaxed text-sm mb-5">
                <p>Shows the relative importance of features used by a model, typically as a bar chart.</p>
                 <p><strong>Backend Role:</strong> Extract feature importances and generate the bar chart image using Matplotlib.</p>
            </div>

            <h3 class="text-lg font-medium text-gray-700 dark:text-gray-200 mb-2">Python Plotting Code (Django View):</h3>
            <pre class="text-xs block overflow-x-auto p-4 bg-gray-900 text-gray-100 rounded-md shadow mb-4"><code class="language-python">
# --- Inside Django View ---
import matplotlib.pyplot as plt
import numpy as np
# ... get feature_names, importances_fi from model ...
indices = np.argsort(importances_fi)[::-1]
sorted_names = [feature_names[i] for i in indices]
sorted_importances = importances_fi[indices]

fig_fi, ax_fi = plt.subplots(figsize=(7, 4))
ax_fi.barh(range(len(sorted_importances)), sorted_importances, align='center', color='skyblue')
ax_fi.set_yticks(range(len(sorted_importances)), sorted_names)
ax_fi.set_xlabel('Feature Importance Score', fontsize=12)
ax_fi.set_ylabel('Feature', fontsize=12)
ax_fi.set_title('Feature Importances', fontsize=14)
ax_fi.invert_yaxis()
plt.tight_layout()

# Save to buffer and encode
# context['feature_importance_b64'] = _plot_to_base64(fig_fi)
# --- End View Snippet ---
            </code></pre>

             <h3 class="text-lg font-medium text-gray-700 dark:text-gray-200 mb-2">Generated Plot:</h3>
              <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded border border-gray-200 dark:border-gray-600 shadow-inner flex justify-center items-center">
                 {% if feature_importance_b64 %}
                    <img src="data:image/png;base64,{{ feature_importance_b64 }}" alt="Feature Importance" class="max-w-full h-auto rounded">
                 {% else %}
                    <p class="text-red-500 italic">[Feature Importance image could not be generated]</p>
                 {% endif %}
             </div>
             <p class="text-xs text-center text-gray-500 dark:text-gray-400 mt-1">Static image generated by Matplotlib.</p>
        </section>

        {# Section: Learning Curve #}
        <section id="learning-curve" class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg dark:shadow-indigo-900/20 transition-colors duration-300 ease-in-out">
            <h2 class="text-2xl font-semibold text-gray-800 dark:text-gray-100 mb-4 border-b border-gray-200 dark:border-gray-700 pb-3">
                4. Learning Curve
            </h2>
            <div class="prose prose-indigo dark:prose-invert max-w-none text-gray-700 dark:text-gray-300 leading-relaxed text-sm mb-5">
                <p>Shows training and validation scores as training set size increases, helping diagnose bias/variance.</p>
                 <p><strong>Backend Role:</strong> Calculate learning curve scores and generate the line plot image using Matplotlib.</p>
            </div>

            <h3 class="text-lg font-medium text-gray-700 dark:text-gray-200 mb-2">Python Plotting Code (Django View):</h3>
             <pre class="text-xs block overflow-x-auto p-4 bg-gray-900 text-gray-100 rounded-md shadow mb-4"><code class="language-python">
# --- Inside Django View ---
import matplotlib.pyplot as plt
import numpy as np
from sklearn.model_selection import learning_curve
# ... get model, X, y ...
train_sizes_abs, train_scores, test_scores = learning_curve(...) # Calculate scores

train_scores_mean_lc = np.mean(train_scores, axis=1)
train_scores_std_lc = np.std(train_scores, axis=1)
test_scores_mean_lc = np.mean(test_scores, axis=1)
test_scores_std_lc = np.std(test_scores, axis=1)

fig_lc, ax_lc = plt.subplots(figsize=(7, 5))
ax_lc.grid(alpha=0.3)
ax_lc.fill_between(train_sizes_abs, train_scores_mean_lc - train_scores_std_lc,
                 train_scores_mean_lc + train_scores_std_lc, alpha=0.1, color="r")
ax_lc.plot(train_sizes_abs, train_scores_mean_lc, 'o-', color="r", label="Training score")
ax_lc.fill_between(train_sizes_abs, test_scores_mean_lc - test_scores_std_lc,
                 test_scores_mean_lc + test_scores_std_lc, alpha=0.1, color="g")
ax_lc.plot(train_sizes_abs, test_scores_mean_lc, 'o-', color="g", label="Cross-validation score")
ax_lc.set_title("Learning Curve", fontsize=14)
ax_lc.set_xlabel("Training Examples", fontsize=12)
ax_lc.set_ylabel("Score (e.g., Accuracy)", fontsize=12)
ax_lc.legend(loc="best", fontsize=10)
ax_lc.set_ylim(max(0, min(test_scores_mean_lc.min(), train_scores_mean_lc.min()) - 0.05), 1.01)
plt.tight_layout()

# Save to buffer and encode
# context['learning_curve_b64'] = _plot_to_base64(fig_lc)
# --- End View Snippet ---
            </code></pre>

             <h3 class="text-lg font-medium text-gray-700 dark:text-gray-200 mb-2">Generated Plot:</h3>
             <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded border border-gray-200 dark:border-gray-600 shadow-inner flex justify-center items-center">
                 {% if learning_curve_b64 %}
                    <img src="data:image/png;base64,{{ learning_curve_b64 }}" alt="Learning Curve" class="max-w-full h-auto rounded">
                 {% else %}
                    <p class="text-red-500 italic">[Learning Curve image could not be generated]</p>
                 {% endif %}
             </div>
             <p class="text-xs text-center text-gray-500 dark:text-gray-400 mt-1">Static image generated by Matplotlib.</p>
        </section>

    </div>

    {# 3. Back Link #}
     <footer class="text-center mt-16">
        <a href="{% url 'portfolio:index' %}" class="text-blue-600 dark:text-blue-400 hover:underline focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-gray-900 rounded">&larr; Back to Home</a>
    </footer>
</div>
{% endblock %} {# Closes the content block #}

{# No extra_js block needed for static image display #}
