# recommendations/tests.py

from django.test import TestCase, Client, RequestFactory
from django.urls import reverse, resolve
from django.utils import timezone
from django.utils.text import slugify
from django.contrib import admin as django_admin_site
from django.contrib.auth.models import User # For admin accessibility tests
from django.db import IntegrityError
from unittest.mock import patch # Ensure patch is imported

import markdown # For checking rendered markdown in detail view tests

from .models import RecommendedProduct, RecommendationSection
from . import views # For URL and view tests
from .admin import RecommendedProductAdmin, RecommendationSectionAdmin, RecommendationSectionInline # For admin tests
from .sitemaps import RecommendationStaticViewSitemap, RecommendedProductSitemap # For sitemap tests
from .context_processors import recommendation_context # For context processor tests

# --- Model Tests ---
class RecommendedProductModelTests(TestCase):
    """
    Tests for the RecommendedProduct model.
    """
    def test_recommended_product_creation_and_defaults(self):
        """Test basic creation, string representation, and default values."""
        product = RecommendedProduct.objects.create(
            name="Test Recommendation Book",
            short_description="A great book for learning.",
            product_url="https://example.com/book",
            category="Book",
            # slug will be auto-generated by save()
        )
        self.assertEqual(product.name, "Test Recommendation Book")
        self.assertEqual(str(product), "Test Recommendation Book")
        self.assertEqual(product.order, 0, "Default order should be 0.")
        self.assertTrue(product.slug, "Slug should be auto-generated.")
        self.assertEqual(product.slug, "test-recommendation-book") # Based on model's save method
        self.assertIsNotNone(product.date_created)
        self.assertIsNotNone(product.last_updated)
        self.assertIsNone(product.main_description_md, "Default main_description_md should be None.")
        self.assertIsNone(product.page_meta_title, "Default page_meta_title should be None.")
        self.assertIsNone(product.image_url, "Default image_url should be None.")


    def test_slug_generation_and_uniqueness_on_save(self):
        """Test slug generation logic in the save method, including uniqueness."""
        prod1 = RecommendedProduct.objects.create(name="Unique Product Name!", product_url="url1")
        self.assertEqual(prod1.slug, "unique-product-name")

        # Test uniqueness for the same name
        prod2 = RecommendedProduct.objects.create(name="Unique Product Name!", product_url="url2")
        self.assertEqual(prod2.slug, "unique-product-name-1", "Second product with same name should have a suffixed slug.")

        # Test uniqueness if a slug is provided that clashes
        prod_custom_slug = RecommendedProduct.objects.create(name="Custom Slug Product", slug="custom-slug", product_url="url3")
        self.assertEqual(prod_custom_slug.slug, "custom-slug")

        prod_custom_slug_conflict = RecommendedProduct.objects.create(name="Another Product", slug="custom-slug", product_url="url4")
        self.assertEqual(prod_custom_slug_conflict.slug, "custom-slug-1", "Conflicting provided slug should be made unique.")

        # Test that an existing slug is not changed on save if it's already set and unique
        prod_custom_slug.name = "Custom Slug Product Updated"
        prod_custom_slug.save()
        self.assertEqual(prod_custom_slug.slug, "custom-slug", "Existing unique slug should not change on save.")

        # Test that if a slug is manually changed to one that exists, it's made unique
        prod_custom_slug.slug = "unique-product-name" # This slug is used by prod1
        prod_custom_slug.save()
        self.assertEqual(prod_custom_slug.slug, "unique-product-name-2") # Should become unique-product-name-2 (or similar, depending on order of operations)

    def test_get_absolute_url(self):
        """Test the get_absolute_url method."""
        product = RecommendedProduct.objects.create(name="URL Test Product", product_url="url")
        expected_url = reverse('recommendations:recommendation_detail', kwargs={'slug': product.slug})
        self.assertEqual(product.get_absolute_url(), expected_url)

    def test_ordering(self):
        """Test the default ordering of RecommendedProduct objects."""
        prod_c = RecommendedProduct.objects.create(name="Product C", order=2, product_url="url_c")
        prod_a = RecommendedProduct.objects.create(name="Product A", order=0, product_url="url_a")
        prod_b_order0 = RecommendedProduct.objects.create(name="Product B", order=0, product_url="url_b") # Same order as A

        products = list(RecommendedProduct.objects.all()) # Uses Meta.ordering = ['order', 'name']
        self.assertEqual(products[0], prod_a, "Product A (order 0, name A) should be first.")
        self.assertEqual(products[1], prod_b_order0, "Product B (order 0, name B) should be second.")
        self.assertEqual(products[2], prod_c, "Product C (order 2) should be third.")


class RecommendationSectionModelTests(TestCase):
    """Tests for the RecommendationSection model."""

    @classmethod
    def setUpTestData(cls):
        cls.product1 = RecommendedProduct.objects.create(name="Main Product for Sections", product_url="url_main")

    def test_recommendation_section_creation(self):
        """Test RecommendationSection creation and its relationship to RecommendedProduct."""
        section = RecommendationSection.objects.create(
            recommendation=self.product1,
            section_order=1.0,
            section_title="Introduction Section",
            section_content_markdown="This is the intro markdown."
        )
        self.assertEqual(section.recommendation, self.product1)
        self.assertEqual(section.section_title, "Introduction Section")
        self.assertEqual(section.section_content_markdown, "This is the intro markdown.")
        self.assertEqual(RecommendationSection.objects.count(), 1)
        self.assertEqual(self.product1.sections.count(), 1)

    def test_recommendation_section_str_representation(self):
        """Test the __str__ method of the RecommendationSection model."""
        section = RecommendationSection.objects.create(
            recommendation=self.product1,
            section_order=1.5,
            section_title="Key Features"
        )
        expected_str = f"{self.product1.name} - Section 1.5 (Key Features)"
        self.assertEqual(str(section), expected_str)

        section_no_title = RecommendationSection.objects.create(recommendation=self.product1, section_order=2.0)
        expected_str_no_title = f"{self.product1.name} - Section 2.0 (Untitled)"
        self.assertEqual(str(section_no_title), expected_str_no_title)


    def test_recommendation_section_ordering(self):
        """Test the ordering of RecommendationSection objects."""
        RecommendationSection.objects.create(recommendation=self.product1, section_order=2.0, section_title="Section Two")
        RecommendationSection.objects.create(recommendation=self.product1, section_order=1.0, section_title="Section One")
        RecommendationSection.objects.create(recommendation=self.product1, section_order=1.5, section_title="Section One Point Five")

        sections = list(self.product1.sections.all()) # Uses Meta.ordering = ['recommendation', 'section_order']
        self.assertEqual(sections[0].section_title, "Section One")
        self.assertEqual(sections[1].section_title, "Section One Point Five")
        self.assertEqual(sections[2].section_title, "Section Two")

    def test_recommendation_section_unique_together_constraint(self):
        """Test unique_together constraint for (recommendation, section_order)."""
        RecommendationSection.objects.create(recommendation=self.product1, section_order=1.0, section_title="First Section")
        with self.assertRaises(IntegrityError):
            RecommendationSection.objects.create(recommendation=self.product1, section_order=1.0, section_title="Duplicate Order Section")

# --- View Tests ---
class RecommendationViewTests(TestCase):
    """
    Tests for the recommendation views (database-driven).
    """
    @classmethod
    def setUpTestData(cls):
        cls.client = Client() # Initialize client here for all tests in this class
        cls.items_per_page = 9 # Match views.recommendation_list_view items_per_page
        cls.num_products_to_create = 12 # To ensure pagination

        for i in range(cls.num_products_to_create):
            RecommendedProduct.objects.create(
                name=f"Reco Product {i+1:02d}", # Ensures correct sorting for testing
                slug=f"reco-product-{i+1:02d}",
                product_url=f"http://example.com/product{i+1}",
                short_description=f"Short desc for product {i+1}",
                order=i # order will be 0, 1, 2, ...
            )

        cls.product_with_sections = RecommendedProduct.objects.get(name="Reco Product 01")
        RecommendationSection.objects.create(
            recommendation=cls.product_with_sections,
            section_order=1.0,
            section_title="First Section Title",
            section_content_markdown="**Bold content** for section 1."
        )
        RecommendationSection.objects.create(
            recommendation=cls.product_with_sections,
            section_order=2.0,
            section_title="Second Section Title",
            section_content_markdown="*Italic content* for section 2."
        )

        cls.product_no_sections_no_main_desc = RecommendedProduct.objects.create(
            name="Product With No Content",
            slug="product-no-content",
            product_url="http://example.com/no-content",
            order=cls.num_products_to_create # Next order
        )

        cls.product_no_sections = RecommendedProduct.objects.create(
            name="Product Without Sections",
            slug="product-without-sections",
            product_url="http://example.com/no-sections",
            main_description_md="# Main Markdown\nThis is the main markdown content.",
            order=cls.num_products_to_create + 1
        )
        cls.total_products_in_db = cls.num_products_to_create + 2 # Added two more products


    def test_recommendation_list_view_status_and_template(self):
        """Test list view returns 200 OK and uses correct template."""
        response = self.client.get(reverse('recommendations:recommendation_list'))
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'recommendations/recommendation_list.html')


    def test_recommendation_list_view_context_and_pagination(self):
        """Test context of the list view, including pagination."""
        response = self.client.get(reverse('recommendations:recommendation_list'))
        self.assertEqual(response.status_code, 200)
        self.assertTrue('recommendations' in response.context, "Context should contain 'recommendations' (page_obj).")
        self.assertEqual(response.context['page_title'], 'Recommendations')
        self.assertIsNone(response.context.get('error_message'), "Error message should be None on successful load.")

        page_obj = response.context['recommendations']
        self.assertEqual(len(page_obj.object_list), min(self.items_per_page, self.total_products_in_db))
        # Check ordering based on 'order' then 'name'
        self.assertEqual(page_obj.object_list[0].name, "Reco Product 01")

        # Test second page if pagination is active
        if page_obj.has_next():
            response_page2 = self.client.get(reverse('recommendations:recommendation_list') + f'?page={page_obj.next_page_number()}')
            self.assertEqual(response_page2.status_code, 200)
            self.assertTrue(len(response_page2.context['recommendations'].object_list) > 0)

    def test_recommendation_list_view_empty_state(self):
        """Test list view when no recommendations exist."""
        RecommendedProduct.objects.all().delete() # Clear all products
        response = self.client.get(reverse('recommendations:recommendation_list'))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.context['recommendations'].object_list), 0)
        self.assertContains(response, "No Recommendations Available") # Check for empty state message in template

    def test_recommendation_detail_view_with_sections_success(self):
        """Test detail view for a product with sections."""
        response = self.client.get(reverse('recommendations:recommendation_detail', kwargs={'slug': self.product_with_sections.slug}))
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'recommendations/recommendation_detail.html')
        self.assertEqual(response.context['product'], self.product_with_sections)
        self.assertIsNotNone(response.context['sections'])
        self.assertEqual(len(response.context['sections']), 2)
        self.assertEqual(response.context['sections'][0]['section_title'], "First Section Title")
        self.assertIn(markdown.markdown(self.product_with_sections.sections.first().section_content_markdown, extensions=['fenced_code', 'codehilite', 'tables']), response.context['sections'][0]['section_content_html'])
        self.assertContains(response, self.product_with_sections.name)

    def test_recommendation_detail_view_with_main_description_success(self):
        """Test detail view for a product with main_description_md and no sections."""
        response = self.client.get(reverse('recommendations:recommendation_detail', kwargs={'slug': self.product_no_sections.slug}))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['product'], self.product_no_sections)
        self.assertIsNotNone(response.context['main_description_html'])
        self.assertIn(markdown.markdown(self.product_no_sections.main_description_md, extensions=['fenced_code', 'codehilite', 'tables']), response.context['main_description_html'])
        self.assertEqual(len(response.context['sections']), 0) # No sections
        self.assertContains(response, self.product_no_sections.name)

    def test_recommendation_detail_view_no_main_desc_no_sections(self):
        """Test detail view for a product with no main_description_md and no sections."""
        response = self.client.get(reverse('recommendations:recommendation_detail', kwargs={'slug': self.product_no_sections_no_main_desc.slug}))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['product'], self.product_no_sections_no_main_desc)
        self.assertEqual(response.context['main_description_html'], "") # Should be empty string
        self.assertEqual(len(response.context['sections']), 0) # No sections
        self.assertContains(response, "No detailed content found for this recommendation.")


    @patch('markdown.markdown')
    def test_recommendation_detail_view_main_markdown_error(self, mock_markdown):
        """Test detail view when markdown processing fails for main_description_md."""
        mock_markdown.side_effect = Exception("Markdown processing failed!")
        response = self.client.get(reverse('recommendations:recommendation_detail', kwargs={'slug': self.product_no_sections.slug}))
        self.assertEqual(response.status_code, 200)
        self.assertIn("Error rendering content.", response.context['main_description_html'])

    @patch('markdown.markdown')
    def test_recommendation_detail_view_section_markdown_error(self, mock_markdown):
        """Test detail view when markdown processing fails for a section's content."""
        # Make markdown fail only for the second call (section content)
        mock_markdown.side_effect = [
            "Processed main description successfully", # For main_description_md if any
            Exception("Section Markdown processing failed!") # For the first section's content
        ]
        if not self.product_with_sections.main_description_md: # if main_description_md is None or empty
             mock_markdown.side_effect = Exception("Section Markdown processing failed!")


        response = self.client.get(reverse('recommendations:recommendation_detail', kwargs={'slug': self.product_with_sections.slug}))
        self.assertEqual(response.status_code, 200)
        self.assertTrue(len(response.context['sections']) > 0)
        self.assertIn("Error rendering section content.", response.context['sections'][0]['section_content_html'])


    def test_recommendation_detail_view_404_for_non_existent_slug(self):
        """Test detail view returns 404 for a non-existent slug."""
        response = self.client.get(reverse('recommendations:recommendation_detail', kwargs={'slug': 'this-slug-does-not-exist'}))
        self.assertEqual(response.status_code, 404)

# --- URL Tests ---
class RecommendationURLTests(TestCase):
    """Tests for the recommendation URL configurations."""

    def test_recommendation_list_url_resolves(self):
        """Test that the list URL resolves to the correct view."""
        url = reverse('recommendations:recommendation_list')
        self.assertEqual(resolve(url).func, views.recommendation_list_view)

    def test_recommendation_detail_url_resolves(self):
        """Test that the detail URL resolves to the correct view and captures slug."""
        test_slug = "a-sample-slug-for-url-test"
        url = reverse('recommendations:recommendation_detail', kwargs={'slug': test_slug})
        resolver_match = resolve(url)
        self.assertEqual(resolver_match.func, views.recommendation_detail_view)
        self.assertEqual(resolver_match.kwargs['slug'], test_slug)

# --- Admin Tests ---
class RecommendationAdminTests(TestCase):
    """Tests for the RecommendedProduct and RecommendationSection admin configurations."""

    @classmethod
    def setUpTestData(cls):
        cls.superuser = User.objects.create_superuser('admin_user', 'admin@example.com', 'password123')
        cls.product = RecommendedProduct.objects.create(name="Admin Test Product", product_url="http://example.com/admin")
        cls.section = RecommendationSection.objects.create(recommendation=cls.product, section_order=1, section_title="Admin Section")


    def setUp(self):
        self.client.login(username='admin_user', password='password123')

    def test_recommendedproduct_is_registered_with_admin(self):
        """Test RecommendedProduct model is registered with RecommendedProductAdmin."""
        self.assertIn(RecommendedProduct, django_admin_site.site._registry)
        self.assertIsInstance(django_admin_site.site._registry[RecommendedProduct], RecommendedProductAdmin)

    def test_recommendationsection_is_registered_with_admin(self):
        """Test RecommendationSection model is registered with RecommendationSectionAdmin."""
        self.assertIn(RecommendationSection, django_admin_site.site._registry)
        self.assertIsInstance(django_admin_site.site._registry[RecommendationSection], RecommendationSectionAdmin)

    def test_recommendedproductadmin_options(self):
        """Test ModelAdmin options for RecommendedProductAdmin."""
        self.assertEqual(RecommendedProductAdmin.list_display, ('name', 'category', 'order', 'product_url', 'last_updated'))
        self.assertEqual(RecommendedProductAdmin.list_filter, ('category',))
        self.assertEqual(RecommendedProductAdmin.search_fields, ('name', 'short_description', 'main_description_md', 'category'))
        self.assertEqual(RecommendedProductAdmin.list_editable, ('order', 'category'))
        self.assertEqual(RecommendedProductAdmin.prepopulated_fields, {'slug': ('name',)})
        self.assertIn(RecommendationSectionInline, RecommendedProductAdmin.inlines) # Check for inline
        # Check a field from each fieldset
        self.assertTrue(any('name' in fs_options['fields'] for _, fs_options in RecommendedProductAdmin.fieldsets if fs_options.get('fields')))
        self.assertTrue(any('short_description' in fs_options['fields'] for _, fs_options in RecommendedProductAdmin.fieldsets if fs_options.get('fields')))

    def test_recommendationsectionadmin_options(self):
        """Test ModelAdmin options for RecommendationSectionAdmin."""
        self.assertEqual(RecommendationSectionAdmin.list_display, ('recommendation', 'section_order', 'section_title'))
        self.assertEqual(RecommendationSectionAdmin.list_filter, ('recommendation__category', 'recommendation__name'))
        self.assertEqual(RecommendationSectionAdmin.search_fields, ('section_title', 'section_content_markdown'))
        self.assertEqual(RecommendationSectionAdmin.autocomplete_fields, ['recommendation'])

    # Admin Page Accessibility Tests
    def test_recommendedproduct_admin_changelist_accessible(self):
        response = self.client.get(reverse('admin:recommendations_recommendedproduct_changelist'))
        self.assertEqual(response.status_code, 200)

    def test_recommendedproduct_admin_add_view_accessible(self):
        response = self.client.get(reverse('admin:recommendations_recommendedproduct_add'))
        self.assertEqual(response.status_code, 200)

    def test_recommendedproduct_admin_change_view_accessible(self):
        response = self.client.get(reverse('admin:recommendations_recommendedproduct_change', args=[self.product.pk]))
        self.assertEqual(response.status_code, 200)

    def test_recommendationsection_admin_changelist_accessible(self):
        response = self.client.get(reverse('admin:recommendations_recommendationsection_changelist'))
        self.assertEqual(response.status_code, 200)

    def test_recommendationsection_admin_add_view_accessible(self):
        response = self.client.get(reverse('admin:recommendations_recommendationsection_add'))
        self.assertEqual(response.status_code, 200)

    def test_recommendationsection_admin_change_view_accessible(self):
        response = self.client.get(reverse('admin:recommendations_recommendationsection_change', args=[self.section.pk]))
        self.assertEqual(response.status_code, 200)


# --- Sitemap Tests ---
class RecommendationSitemapTests(TestCase):
    """Tests for the recommendation sitemaps."""

    @classmethod
    def setUpTestData(cls):
        cls.prod1 = RecommendedProduct.objects.create(name="Sitemap Rec 1", product_url="url1", last_updated=timezone.now())
        cls.prod2 = RecommendedProduct.objects.create(name="Sitemap Rec 2", product_url="url2", last_updated=timezone.now() - timezone.timedelta(days=1))

    def test_recommendation_static_view_sitemap_properties(self):
        """Test properties of RecommendationStaticViewSitemap."""
        sitemap = RecommendationStaticViewSitemap()
        self.assertEqual(list(sitemap.items()), ['recommendations:recommendation_list'])
        self.assertEqual(sitemap.location('recommendations:recommendation_list'), reverse('recommendations:recommendation_list'))
        self.assertEqual(sitemap.priority, 0.7)
        self.assertEqual(sitemap.changefreq, 'weekly')

    def test_recommended_product_sitemap_properties(self):
        """Test properties of RecommendedProductSitemap."""
        sitemap = RecommendedProductSitemap()
        sitemap_items = list(sitemap.items())

        self.assertIn(self.prod1, sitemap_items)
        self.assertIn(self.prod2, sitemap_items)
        self.assertEqual(len(sitemap_items), RecommendedProduct.objects.count())

        # Test properties for a specific item
        if self.prod1 in sitemap_items:
            self.assertEqual(sitemap.location(self.prod1), self.prod1.get_absolute_url())
            self.assertEqual(sitemap.lastmod(self.prod1), self.prod1.last_updated)
            self.assertEqual(sitemap.priority, 0.6)
            self.assertEqual(sitemap.changefreq, "monthly")

# --- Context Processor Tests ---
class RecommendationContextProcessorTests(TestCase):
    """Tests for the recommendation_context context processor."""

    def setUp(self):
        self.factory = RequestFactory()

    def test_recommendation_count_with_products(self):
        """Test context processor when products exist."""
        RecommendedProduct.objects.create(name="Prod Context 1", product_url="url_ctx1", order=1)
        RecommendedProduct.objects.create(name="Prod Context 2", product_url="url_ctx2", order=2)
        request = self.factory.get('/')
        context = recommendation_context(request)
        self.assertIn('recommendation_count', context)
        self.assertEqual(context['recommendation_count'], 2)

    def test_recommendation_count_no_products(self):
        """Test context processor when no products exist."""
        RecommendedProduct.objects.all().delete() # Ensure no products
        request = self.factory.get('/')
        context = recommendation_context(request)
        self.assertIn('recommendation_count', context)
        self.assertEqual(context['recommendation_count'], 0)

    @patch('recommendations.context_processors.RecommendedProduct.objects.count')
    def test_recommendation_count_db_exception(self, mock_count):
        """Test context processor when a DB exception occurs during count."""
        mock_count.side_effect = Exception("Database error")
        request = self.factory.get('/')
        # Ensure the logger name matches the one used in context_processors.py
        with self.assertLogs('recommendations.context_processors', level='WARNING') as log_cm:
            context = recommendation_context(request)
            self.assertTrue(any("Could not query RecommendedProduct count" in message for message in log_cm.output))
        self.assertIn('recommendation_count', context)
        self.assertEqual(context['recommendation_count'], 0)

    @patch('recommendations.context_processors.RECOMMENDATIONS_APP_AVAILABLE', False)
    def test_recommendation_count_app_not_available(self):
        """Test context processor when RECOMMENDATIONS_APP_AVAILABLE is False."""
        request = self.factory.get('/')
        context = recommendation_context(request)
        self.assertIn('recommendation_count', context)
        self.assertEqual(context['recommendation_count'], 0)
